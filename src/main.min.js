const SName=Symbol("storage-name"),IDB=Symbol("idb");export class EverCache{constructor(e="public"){return this[SName]=e,this[IDB]=new Promise(t=>{let r=indexedDB.open("ever-cache");r.onsuccess=(e=>{t(e.target.result)}),r.onupgradeneeded=(t=>{t.target.result.createObjectStore(e,{keyPath:"key"})})}),new Proxy(this,handle)}async setItem(e,t){return commonTask(this,r=>r.put({key:e,value:t})).then(()=>!0)}async getItem(e){return commonTask(this,t=>t.get(e),"readonly").then(e=>{const{result:t}=e.target;return t?t.value:null})}async removeItem(e){return commonTask(this,t=>t.delete(e)).then(()=>!0)}async clear(){return commonTask(this,e=>e.clear()).then(()=>!0)}async key(e){return commonTask(this,e=>e.getAllKeys()).then(t=>t.target.result[e])}get length(){return commonTask(this,e=>e.count()).then(e=>e.target.result)}}const exitedKeys=new Set(Object.getOwnPropertyNames(EverCache.prototype)),handle={get:(e,t,r)=>exitedKeys.has(t)||"symbol"==typeof t?Reflect.get(e,t,r):e.getItem(t),set:(e,t,r)=>e.setItem(t,r),deleteProperty:(e,t)=>e.removeItem(t)},commonTask=async(e,t,r="readwrite")=>{const n=await e[IDB];return new Promise((s,o)=>{const a=t(n.transaction([e[SName]],r).objectStore(e[SName]));a.onsuccess=(e=>{s(e)}),a.onerror=(e=>{o(e)})})};export const storage=new EverCache;