const SName=Symbol("storage-name"),IDB=Symbol("idb");export class EverCache{constructor(e="public"){return this[SName]=e,this[IDB]=new Promise(t=>{let r=indexedDB.open("ever-cache");r.onsuccess=(e=>{t(e.target.result)}),r.onupgradeneeded=(t=>{t.target.result.createObjectStore(e,{keyPath:"key"})})}),new Proxy(this,handle)}async setItem(e,t){return commonTask(this,r=>r.put({key:e,value:t}),()=>!0)}async getItem(e){return commonTask(this,t=>t.get(e),e=>{const{result:t}=e.target;return t?t.value:null},"readonly")}async removeItem(e){return commonTask(this,t=>t.delete(e),()=>!0)}async clear(){return commonTask(this,e=>e.clear(),()=>!0)}async key(e){return commonTask(this,e=>e.getAllKeys(),t=>t.target.result[e])}get length(){return commonTask(this,e=>e.count(),e=>e.target.result)}}const exitedKeys=new Set(Object.getOwnPropertyNames(EverCache.prototype)),handle={get:(e,t,r)=>exitedKeys.has(t)||"symbol"==typeof t?Reflect.get(e,t,r):e.getItem(t),set:(e,t,r)=>e.setItem(t,r),deleteProperty:(e,t)=>e.removeItem(t)},commonTask=async(e,t,r,s="readwrite")=>{const n=await e[IDB];return new Promise((o,a)=>{const c=t(n.transaction([e[SName]],s).objectStore(e[SName]));c.onsuccess=(e=>{o(r(e))}),c.onerror=(e=>{a(e)})})};export const storage=new EverCache;