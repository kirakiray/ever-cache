const SName=Symbol("storage-name"),IDB=Symbol("idb");export class EverCache{constructor(e="public"){return this[SName]=e,this[IDB]=new Promise(t=>{let r=indexedDB.open("ever-cache");r.onsuccess=(e=>{t(e.target.result)}),r.onupgradeneeded=(t=>{t.target.result.createObjectStore(e,{keyPath:"key"})})}),new Proxy(this,handle)}async setItem(e,t){return commonTask(this,r=>r.put({key:e,value:t})).then(()=>!0)}async getItem(e){return commonTask(this,t=>t.get(e),"readonly").then(e=>{const{result:t}=e.target;return t?t.value:null})}async removeItem(e){return commonTask(this,t=>t.delete(e)).then(()=>!0)}async clear(){return commonTask(this,e=>e.clear()).then(()=>!0)}async key(e){return commonTask(this,e=>e.getAllKeys()).then(t=>t.target.result[e])}get length(){return commonTask(this,e=>e.count()).then(e=>e.target.result)}entries(){return{[Symbol.asyncIterator]:()=>{let e,t;const r=()=>{t=new Promise(t=>e=t)};return r(),commonTask(this,e=>e.openCursor(),"readonly",t=>e(t.target.result)),{async next(){const e=await t;if(!e)return{done:!0};r();const{key:n,value:s}=e.value;return e.continue(),{value:[n,s],done:!1}}}}}}async*keys(){for await(let[e,t]of this.entries())yield e}async*values(){for await(let[e,t]of this.entries())yield t}}const exitedKeys=new Set(Object.getOwnPropertyNames(EverCache.prototype)),handle={get:(e,t,r)=>exitedKeys.has(t)||"symbol"==typeof t?Reflect.get(e,t,r):e.getItem(t),set:(e,t,r)=>e.setItem(t,r),deleteProperty:(e,t)=>e.removeItem(t)},commonTask=async(e,t,r="readwrite",n)=>{const s=await e[IDB];return new Promise((o,a)=>{const c=t(s.transaction([e[SName]],r).objectStore(e[SName]));c.onsuccess=(e=>{if(n){const t=n(e);t&&o(t)}else o(e)}),c.onerror=(e=>{a(e)})})};export const storage=new EverCache;