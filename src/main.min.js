const SName=Symbol("storage-name"),IDB=Symbol("idb");export class EverCache{constructor(e="public"){return this[SName]="main",this[IDB]=new Promise(t=>{let n=indexedDB.open(`ever-cache-${e}`);n.onsuccess=(e=>{t(e.target.result)}),n.onupgradeneeded=(e=>{e.target.result.createObjectStore("main",{keyPath:"key"})})}),new Proxy(this,handle)}async setItem(e,t){return commonTask(this,n=>n.put({key:e,value:t})).then(()=>!0)}async getItem(e){return commonTask(this,t=>t.get(e),"readonly").then(e=>{const{result:t}=e.target;return t?t.value:null})}async removeItem(e){return commonTask(this,t=>t.delete(e)).then(()=>!0)}async clear(){return commonTask(this,e=>e.clear()).then(()=>!0)}async key(e){return commonTask(this,e=>e.getAllKeys()).then(t=>t.target.result[e])}get length(){return commonTask(this,e=>e.count()).then(e=>e.target.result)}entries(){return{[Symbol.asyncIterator]:()=>{let e,t;const n=()=>{t=new Promise(t=>e=t)};return n(),commonTask(this,e=>e.openCursor(),"readonly",t=>e(t.target.result)),{async next(){const e=await t;if(!e)return{done:!0};n();const{key:r,value:s}=e.value;return e.continue(),{value:[r,s],done:!1}}}}}}async*keys(){for await(let[e,t]of this.entries())yield e}async*values(){for await(let[e,t]of this.entries())yield t}}const exitedKeys=new Set(Object.getOwnPropertyNames(EverCache.prototype)),handle={get:(e,t,n)=>exitedKeys.has(t)||"symbol"==typeof t?Reflect.get(e,t,n):e.getItem(t),set:(e,t,n)=>e.setItem(t,n),deleteProperty:(e,t)=>e.removeItem(t)},commonTask=async(e,t,n="readwrite",r)=>{const s=await e[IDB];return new Promise((o,a)=>{const c=t(s.transaction([e[SName]],n).objectStore(e[SName]));c.onsuccess=(e=>{if(r){const t=r(e);t&&o(t)}else o(e)}),c.onerror=(e=>{a(e)})})};export const storage=new EverCache;